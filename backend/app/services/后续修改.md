结论与优先级

- 根因1（最高优先级）：后端在构建/查询向量库时使用的是“SimpleEmbeddings”（伪随机向量），没有任何语义能力，检索结果基本等同于随机。这是导致“不相关”的决定性原因。建议马上换成真实语义模型（如中文专用 bge 系列/多语模型），并重建向量库。参见文件： `vector_service.py`
- 根因2：相似度“分数”理解与阈值过滤逻辑存在方向性错误风险。当前代码把分数一律当作“越大越相似”，而 FAISS 默认返回的是“距离”（越小越近）。如果将来把阈值从 0 提高，会导致“距离更大（更不相似）”的文档被保留、相似的被过滤。需要统一“分数=相似度”的定义或在阈值比较前做转换。参见文件： `vector_retriever.py`
- 根因3：MMR 分数重算使用了与入库时不同的文本（未加“标题/类别”前缀），且仍然用 SimpleEmbeddings，导致与索引构建时的向量空间不一致，MMR 排序会进一步劣化。建议在重算相似度时使用与入库一致的“前缀拼接文本”和同一嵌入模型。参见文件： `vector_retriever.py` 和 `vector_service.py`
- 次要原因1：前端未传 category，后端虽有“类目加权/过滤/降权”机制，但没有输入类目就无法启用，有些“收费/价格/商务类”的问题会被 QMS 质量手册类文档淹没。建议在前端提供类目选择或在后端做关键词→类目引导。参见文件： `QA.tsx`
- 次要原因2：当前阈值设置为 0.0，等于不做任何过滤；k 也偏小（默认 4 或 5），在语义向量无效的情况下会得到不稳定的“Top-k”。在替换真实嵌入后再调优为合理的 k 和阈值。
端到端链路详解与问题定位

1. 1.
   前端发起请求
- 页面与请求代码：
  - 问答页： `QA.tsx`
  - API 封装： `qaApi.ts`
- 现状：
  - 调用 ask 时仅发送 question 与 use_multi_retrieval，未传 category（QA.tsx 的 handleAskQuestion 中构建的 QuestionRequest）。这使得后端的“类目加权/过滤”能力无法发挥，对“收费标准”这类强类别问题（更偏财务/商务）不利。
- 建议：
  - 在前端增加类目下拉选择并随请求传给后端（字段名即 schemas 中的 category）。
  - 或由后端做关键词→类目自动引导（比如捕捉“收费/价格/费用/费率/合同/报价”等关键词，优先路由到“政策/合同/财务/商务”类目）。
2. 1.
   后端 API 与问答服务
- API 入口： `qa.py` 的 /api/v1/qa/ask
- Pydantic 模型： `schemas.py` 中 QuestionRequest（use_multi_retrieval 默认 True）
- 统一检索配置与实例化：
  - 配置工厂： `config_factory.py`
  - 统一检索： `unified_retrieval_service.py`
- 现状：
  - 默认模式 AUTO，会在向量/混合/多查询/集成之间自动选择；但无论选择哪种，只要底层向量是“伪随机”，召回就会严重跑偏。
  - 基础 k 与阈值来源 settings（默认检索阈值为 0.0，不过滤）。
- 建议：
  - 先修好底层向量（替换嵌入并重建索引），再基于真实分数设置合理阈值和 k。
3. 1.
   检索核心：向量检索器与向量服务
- 向量服务： `vector_service.py`
  - 当前使用 SimpleEmbeddings(dimension=384) 生成“伪随机向量”，这会导致所有相似度计算失去语义基础（这是最致命的问题）。
  - 入库前会做“标题/类别”前缀拼接（_build_prefixed_text），这点是加分项，但因为嵌入模型是假的，收益为零。
- 向量检索器： `vector_retriever.py`
  - 阈值过滤把“score >= similarity_threshold”当作“越大越相似”的逻辑，而 FAISS 默认为 L2 距离（越小越近）。当阈值提升时会出现“过滤掉好文档、保留坏文档”的方向性错误。
  - 使用 MMR 时，为每个返回文档重新计算 query-doc 相似度，却用的是 doc.page_content（未加前缀）且仍用 SimpleEmbeddings，和索引构建时（有前缀的文本）不一致，排序不稳定。
4. 1.
   设置层
- settings（config.py）中阈值与 MMR： `config.py`
  - retrieval_similarity_threshold=0.0，filter_search_multiplier=10，vector_mmr_fetch_k=20，vector_mmr_lambda_mult=0.5。
  - 阈值为 0 目前等价于不过滤；在改用真实嵌入后，需要基于实际分数范围重新设定（例如余弦相似度>0.25~0.35 的经验阈值）。
为什么在你的样例问题上会不相关

- 你的问题“非制造焊接返修订单收费标准”属于“收费/价格/商务/财务”的范畴。当前语料主轴是 QMS/质量手册内容，且未提供类目输入；再叠加“伪随机嵌入”，系统大概率返回与“收费标准”不相关的质量流程/控制程序段落，表现为“看起来回答了，但不相关”。
- 即使有语义嵌入，若知识库确实没有“收费标准/报价/合同价格/服务费率”类文档，也会无法命中。这需要从数据侧补齐文档或在问答层面直接提醒“文库无此信息”。
可复现与验证点

- 打开向量日志（前端已在提问前调用 /api/v1/qa/vector-logs），日志里可观察到：
  - 使用的向量维度、向量条数等（在 `vector_service.py` 加载/保存日志中有统计输出）。
  - 检索模式（在 `unified_retrieval_service.py` 会将检索模式写入 metadata）。
- 如果你临时把 SimpleEmbeddings 换成真实模型（例如 HuggingFaceEmbeddings 或 OpenAI Embeddings）并重建索引，立刻能观察到相关性显著提升，这能佐证根因判断。
落地修复方案（按优先级）

1. 1.
   替换嵌入模型并重建向量库（必须）
- 在 `vector_service.py` 用真实模型替换 SimpleEmbeddings，例如：
  - 中文优先：BAAI/bge-small-zh-v1.5 或 bge-m3
  - 多语：sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2
  - 或 OpenAI text-embedding-3-large（需配置密钥）
- 重建索引（项目内已有 rebuild/init 脚本），确保新索引与新模型一致。
2. 1.
   统一分数语义与阈值逻辑（必须）
- 明确定义“分数=相似度（越大越相似）”。若底层 FAISS 返回距离，需要把距离转换为相似度（例如对归一化向量可使用 similarity = 1 - distance/2 或直接使用内积索引）。
- 在 `vector_retriever.py` 的阈值过滤处，将“score >= threshold”改为对“相似度”的比较，确保含义一致；或在取回结果后先统一转换为相似度再排序/过滤。
- 若继续使用 cosine 方案，建议确保向量已单位化并使用 IndexFlatIP（内积）以便“越大越相似”的语义天然成立。
3. 1.
   统一 MMR 的相似度计算输入与模型（必须）
- 在 MMR 回排时，对文档使用与入库完全一致的“前缀拼接文本”（标题/类别 + 正文）来生成文档向量；或者避免重算，直接基于向量库提供的结果进行多样性选择（如利用 embeddings cache 或在入库阶段持久化文档向量）。
- 确保使用同一个真实嵌入模型实例，避免 SimpleEmbeddings 干扰。
4. 1.
   打开类目引导与降权（强烈建议）
- 前端：在 `QA.tsx` 增加 category 选择，并把该字段传到后端（QuestionRequest.category）。
- 后端：基于关键词（如“收费/价格/费用/费率/报价/合同/结算”）进行类目引导，将 query 的默认检索类目优先设为“政策/商务/财务”相关；同时对“质量手册/QMS/体系/流程”等关键词命中文档施加轻度降权，避免“误强答”。
5. 1.
   在换用真实嵌入后，调优参数（建议）
- k：从 4/5 提升到 8~12 以增加召回，再用 reranking 压制噪音。
- similarity_threshold：根据选用模型的分数分布，设定如 0.25~0.35 的初始阈值，结合日志观察再微调。
- 若短问句偏多，Hybrid 模式 + 轻量 reranking 效果通常更稳。
6. 1.
   数据侧核查（必要时）
- 如果知识库确实没有“非制造焊接返修订单收费标准/服务费率/报价”类文档，需要补齐数据；或者在问答层明确提示“知识库暂无该类财务定价信息”。
需要我来直接改哪几处代码/配置并重建索引吗？

- 我可以按上述优先级帮你：
  1. 1.
     将 SimpleEmbeddings 替换为指定的真实模型；
  2. 2.
     统一分数语义与阈值逻辑；
  3. 3.
     统一 MMR 的相似度计算入口；
  4. 4.
     在前端加一个简洁的类目选择并接到后端；
  5. 5.
     重建向量库并做一次端到端验证（你可直接在前端查看“向量搜索日志”和答案来源对比）。
- 你